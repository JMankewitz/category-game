<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Category Game - Display</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            overflow: hidden;
        }

        .main-content {
            text-align: center;
            max-width: 90vw;
            width: 100%;
        }

        .room-code {
            position: absolute;
            top: 2rem;
            right: 2rem;
            background: rgba(255,255,255,0.2);
            padding: 1rem 2rem;
            border-radius: 12px;
            font-size: 1.5rem;
            font-weight: 700;
            letter-spacing: 0.2em;
        }

        .game-title {
            font-size: 4rem;
            font-weight: 800;
            margin-bottom: 2rem;
            text-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        .category-display {
            font-size: 6rem;
            font-weight: 700;
            margin: 2rem 0;
            text-shadow: 0 4px 8px rgba(0,0,0,0.3);
            line-height: 1.2;
        }

        .phase-message {
            font-size: 2.5rem;
            margin: 2rem 0;
            opacity: 0.9;
        }

        .submission-counter {
            font-size: 1.8rem;
            font-weight: 600;
            background: rgba(255,255,255,0.2);
            padding: 1rem 2rem;
            border-radius: 15px;
            margin: 1rem auto;
            max-width: 400px;
        }

        .vote-counter {
            font-size: 3rem;
            font-weight: 600;
            background: rgba(255,255,255,0.2);
            padding: 2rem;
            border-radius: 20px;
            margin: 2rem auto;
            max-width: 600px;
        }

        /* Voting visualization */
        .voting-arena {
            position: relative;
            width: 80vw;
            height: 60vh;
            margin: 2rem auto;
            border-radius: 20px;
            background: rgba(255,255,255,0.1);
            overflow: hidden;
            display: flex;
        }

        .vote-side {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            padding: 2rem;
        }

        .vote-side.yes {
            background: rgba(40, 167, 69, 0.3);
            border-right: 3px solid rgba(255,255,255,0.3);
        }

        .vote-side.no {
            background: rgba(220, 53, 69, 0.3);
        }

        .vote-label {
            font-size: 4rem;
            font-weight: 700;
            margin-bottom: 2rem;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .vote-count {
            font-size: 3rem;
            font-weight: 700;
            margin-top: 1rem;
            background: rgba(255,255,255,0.2);
            border-radius: 50%;
            width: 100px;
            height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .player-circle {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: white;
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            color: #333;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            transition: all 1.2s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            font-size: 0.9rem;
            z-index: 10;
        }

        .player-circle.animating {
            transform: translate(-50%, -50%) scale(1.1);
            box-shadow: 0 6px 20px rgba(0,0,0,0.4);
        }

        /* Controversy Summary */
        .controversy-container {
            display: flex;
            gap: 3rem;
            justify-content: center;
            max-width: 90vw;
            margin: 0 auto;
        }

        .controversy-section {
            flex: 1;
            max-width: 500px;
        }

        .controversy-title {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 2rem;
            text-align: center;
        }

        .controversy-title.most {
            color: #ff6b6b;
        }

        .controversy-title.least {
            color: #4ecdc4;
        }

        .controversy-list {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .controversy-item {
            background: rgba(255,255,255,0.15);
            padding: 1.5rem;
            border-radius: 15px;
            text-align: center;
            animation: slideIn 0.6s ease-out;
        }

        .controversy-exemplar {
            font-size: 1.8rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
        }

        .controversy-split {
            font-size: 1.2rem;
            opacity: 0.9;
        }

        .controversy-points {
            font-size: 1.4rem;
            font-weight: 700;
            color: #ffd700;
            margin-top: 0.5rem;
        }

        /* Scoreboard */
        .scoreboard {
            background: rgba(255,255,255,0.15);
            border-radius: 20px;
            padding: 3rem;
            margin: 2rem auto;
            max-width: 800px;
        }

        .scoreboard-title {
            font-size: 3rem;
            font-weight: 700;
            margin-bottom: 2rem;
            text-align: center;
        }

        .score-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 2rem;
            margin: 0.5rem 0;
            background: rgba(255,255,255,0.1);
            border-radius: 12px;
            font-size: 1.8rem;
        }

        .score-rank {
            font-weight: 700;
            margin-right: 1rem;
            color: #ffd700;
        }
        
        .controversy-section.full-width {
            max-width: 800px;
            margin: 0 auto;
        }

        .controversy-rank {
            font-size: 1.1rem;
            font-weight: 700;
            color: #ffd700;
            margin-bottom: 0.3rem;
        }

        /* Timer display styles */
        .timer-display {
            position: fixed;
            top: 50%;
            right: 2rem;
            transform: translateY(-50%);
            background: rgba(255,255,255,0.9);
            padding: 1.5rem;
            border-radius: 15px;
            text-align: center;
            min-width: 120px;
            box-shadow: 0 8px 20px rgba(0,0,0,0.2);
            z-index: 100;
        }

        .timer-label {
            font-size: 0.9rem;
            font-weight: 600;
            color: #666;
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .timer-countdown {
            font-size: 2.5rem;
            font-weight: 700;
            color: #333;
            margin-bottom: 0.3rem;
            font-family: 'Courier New', monospace;
        }

        .timer-countdown.warning {
            color: #ff6b6b;
            animation: timerPulse 1s infinite;
        }

        .timer-countdown.critical {
            color: #ff3333;
            animation: timerPulse 0.5s infinite;
        }

        .timer-phase {
            font-size: 0.8rem;
            color: #888;
            font-style: italic;
        }

        @keyframes timerPulse {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.1);
            }
        }

        .timer-progress {
            width: 100%;
            height: 4px;
            background: rgba(0,0,0,0.1);
            border-radius: 2px;
            margin-top: 0.5rem;
            overflow: hidden;
        }

        .timer-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #4ecdc4, #44a08d);
            border-radius: 2px;
            transition: width 1s linear;
        }

        .timer-progress-bar.warning {
            background: linear-gradient(90deg, #ffa726, #ff9800);
        }

        .timer-progress-bar.critical {
            background: linear-gradient(90deg, #ff6b6b, #ee5a24);
        }

        /* Hide timer when not needed */
        .timer-display.hidden {
            display: none;
        }

        /* Mobile responsiveness */
        @media (max-width: 768px) {
            .timer-display {
                position: fixed;
                top: 1rem;
                right: 1rem;
                left: auto;
                transform: none;
                min-width: 100px;
                padding: 1rem;
            }
            
            .timer-countdown {
                font-size: 2rem;
            }
        }

        .final-score {
            background: linear-gradient(45deg, rgba(255,215,0,0.1), rgba(255,255,255,0.1));
            border: 2px solid rgba(255,215,0,0.3);
        }

        .final-score:first-child {
            background: linear-gradient(45deg, rgba(255,215,0,0.2), rgba(255,255,255,0.15));
            border: 2px solid rgba(255,215,0,0.5);
            box-shadow: 0 0 20px rgba(255,215,0,0.3);
        }
        .hidden {
            display: none;
        }

        /* Player bubbles for waiting screen */
        .players-waiting {
            margin-top: 3rem;
            max-width: 80vw;
        }

        .waiting-subtitle {
            font-size: 2rem;
            font-weight: 600;
            margin-bottom: 2rem;
            opacity: 0.9;
        }

        .player-bubbles {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 1.5rem;
            margin: 0 auto;
            max-width: 800px;
        }

        .player-bubble {
            background: rgba(255,255,255,0.9);
            color: #333;
            padding: 1rem 1.5rem;
            border-radius: 50px;
            font-size: 1.3rem;
            font-weight: 600;
            box-shadow: 0 8px 20px rgba(0,0,0,0.15);
            position: relative;
            overflow: hidden;
            transition: all 0.4s ease;
        }

        .player-bubble.new {
            transform: scale(0);
            animation: bubblePop 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55) forwards,
                       glow 1s ease-in-out;
        }

        .player-bubble.existing {
            /* Existing bubbles just use the transition for smooth movement */
        }

        .category-submissions {
            margin-top: 2rem;
            max-width: 80vw;
        }

        .category-subtitle {
            font-size: 2rem;
            font-weight: 600;
            margin-bottom: 1.5rem;
            opacity: 0.9;
            text-align: center;
        }

        .category-bubbles {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 1rem;
            margin: 0 auto;
            max-width: 800px;
            min-height: 80px;
            align-items: center;
        }

        .category-bubble {
            background: rgba(255,255,255,0.8);
            color: #333;
            padding: 0.8rem 1.2rem;
            border-radius: 25px;
            font-size: 1.1rem;
            font-weight: 500;
            box-shadow: 0 6px 15px rgba(0,0,0,0.1);
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
            border-left: 4px solid #667eea;
        }

        .category-bubble.new {
            transform: scale(0);
            animation: categoryPop 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55) forwards;
        }

        .category-bubble::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
            transition: left 0.5s;
        }

        .category-bubble:hover::before {
            left: 100%;
        }

        @keyframes categoryPop {
            0% {
                transform: scale(0) rotate(-180deg);
                opacity: 0;
            }
            50% {
                transform: scale(1.1) rotate(90deg);
            }
            100% {
                transform: scale(1) rotate(0deg);
                opacity: 1;
            }
        }

        .no-categories-message {
            font-size: 1.3rem;
            opacity: 0.6;
            font-style: italic;
            color: rgba(255,255,255,0.8);
        }

        /* Host controls */
        .host-controls {
            position: fixed;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255,255,255,0.95);
            padding: 2rem;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            backdrop-filter: blur(10px);
            min-width: 400px;
        }

        .host-section h3 {
            color: #333;
            margin-bottom: 1rem;
            text-align: center;
            font-size: 1.3rem;
        }

        .control-group {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .host-input {
            flex: 1;
            padding: 0.8rem;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 1rem;
        }

        .host-input:focus {
            outline: none;
            border-color: #667eea;
        }

        .host-button {
            background: #667eea;
            color: white;
            border: none;
            padding: 0.8rem 1.5rem;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
        }

        .host-button:hover {
            background: #5a6fd8;
            transform: translateY(-1px);
        }

        .start-game-button {
            width: 100%;
            background: #28a745;
            color: white;
            border: none;
            padding: 1rem;
            border-radius: 8px;
            font-size: 1.1rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .start-game-button:hover:not(:disabled) {
            background: #218838;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3);
        }

        .start-game-button:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
        }

        @media (max-width: 768px) {
            .host-controls {
                position: relative;
                margin-top: 2rem;
                left: auto;
                transform: none;
                min-width: auto;
                width: 90%;
                margin: 2rem auto 0;
            }
            
            .control-group {
                flex-direction: column;
            }
        }

        @keyframes bubblePop {
            0% {
                transform: scale(0) rotate(0deg);
                opacity: 0;
            }
            50% {
                transform: scale(1.2) rotate(180deg);
            }
            100% {
                transform: scale(1) rotate(360deg);
                opacity: 1;
            }
        }

        @keyframes shimmer {
            0% {
                left: -100%;
            }
            100% {
                left: 100%;
            }
        }

        @keyframes glow {
            0%, 100% {
                box-shadow: 0 8px 20px rgba(0,0,0,0.15);
            }
            50% {
                box-shadow: 0 8px 30px rgba(102, 126, 234, 0.4),
                           0 0 0 3px rgba(102, 126, 234, 0.3);
            }
        }

        .no-players-message {
            font-size: 1.5rem;
            opacity: 0.7;
            font-style: italic;
        }

        /* Animations */
        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% {
                transform: translateY(0);
            }
            40% {
                transform: translateY(-20px);
            }
            60% {
                transform: translateY(-10px);
            }
        }

        .bounce {
            animation: bounce 1s;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(50px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .slide-in {
            animation: slideIn 0.6s ease-out;
        }

        @media (max-width: 768px) {
            .controversy-container {
                flex-direction: column;
                gap: 2rem;
            }
            
            .voting-arena {
                height: 50vh;
            }
            
            .vote-count {
                width: 80px;
                height: 80px;
                font-size: 2rem;
            }

            .game-title {
                font-size: 2.5rem;
            }

            .category-display {
                font-size: 3rem;
            }

            .phase-message {
                font-size: 1.8rem;
            }
        }
    </style>
</head>
<body>
    <div class="room-code" id="roomCode">XXXX</div>
    <div class="timer-display hidden" id="timerDisplay">
        <div class="timer-label" id="timerLabel">Time Remaining</div>
        <div class="timer-countdown" id="timerCountdown">0:00</div>
        <div class="timer-phase" id="timerPhase">Waiting...</div>
        <div class="timer-progress">
            <div class="timer-progress-bar" id="timerProgressBar"></div>
        </div>
    </div>
    <div class="main-content">
        <!-- Waiting for room connection -->
        <div id="waitingScreen">
            <div class="game-title">Category Game</div>
            <div class="phase-message" id="waitingMessage">Waiting for game to start...</div>
            
            <!-- Player bubbles container -->
            <div class="players-waiting" id="playersWaiting">
                <div class="waiting-subtitle">Players Joined:</div>
                <div class="player-bubbles" id="playerBubbles">
                    <!-- Player bubbles will appear here -->
                </div>
            </div>
        </div>

        <!-- Lobby/Category Management Screen -->
        <div id="lobbyScreen" class="hidden">
            <div class="game-title">Category Game Lobby</div>
            <div class="phase-message" id="lobbyMessage">Players are joining and submitting categories...</div>
            
            <!-- Player bubbles container (reuse existing) -->
            <div class="players-waiting" id="lobbyPlayersWaiting">
                <div class="waiting-subtitle">Players Joined:</div>
                <div class="player-bubbles" id="lobbyPlayerBubbles">
                    <!-- Player bubbles will appear here -->
                </div>
            </div>
            
            <!-- Category submissions display -->
            <div class="category-submissions">
                <div class="category-subtitle">Categories Submitted:</div>
                <div class="category-bubbles" id="categoryBubbles">
                    <div class="no-categories-message">No categories submitted yet...</div>
                </div>
            </div>
            
            <!-- Host controls -->
            <div class="host-controls">
                <div class="host-section">
                    <h3>Host Controls</h3>
                    <button id="startGameBtn" class="start-game-button" disabled>
                        Start Game (Need 2+ players and 3+ categories)
                    </button>
                    <div class="control-group">
                        <input type="text" id="hostCategoryInput" class="host-input" 
                            placeholder="Add a category..." maxlength="50">
                        <button id="addCategoryBtn" class="host-button">Add Category</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Category display phase -->
        <div id="categoryScreen" class="hidden">
            <div class="phase-message">Current Category</div>
            <div class="category-display" id="categoryText">"Furniture"</div>
            <div class="phase-message" id="phaseMessage">Players are submitting exemplars...</div>
            <div class="submission-counter" id="submissionCounter">0 / 8 players have submitted</div>
        </div>

        <!-- Voting counter -->
        <div id="votingScreen" class="hidden">
            <div class="phase-message">Voting for Category:</div>
            <div class="category-display" id="votingCategoryDisplay">"Furniture"</div>
            <div class="phase-message">Voting in Progress</div>
            <div class="vote-counter" id="voteCounter">5 / 8 players have voted</div>
        </div>

        <!-- Individual Exemplar Results -->
        <div id="resultsScreen" class="hidden">
            <div class="phase-message">
                <span id="resultProgress">Result 1 of 5</span>
            </div>
            <div class="phase-message">
                <span id="currentExemplar">"Chair"</span>
            </div>
            
            <div class="voting-arena" id="votingArena">
                <div class="vote-side yes">
                    <div class="vote-label">üëç YES</div>
                    <div class="vote-count" id="yesCount">0</div>
                </div>
                <div class="vote-side no">
                    <div class="vote-label">üëé NO</div>
                    <div class="vote-count" id="noCount">0</div>
                </div>
            </div>
            
            <div class="vote-counter" id="splitDisplay">Split: 6 YES, 2 NO (2 points)</div>
        </div>

        <!-- Controversy Summary -->
        <div id="controversySummary" class="hidden">
            <div class="phase-message">Most & Least Controversial</div>
            <div class="controversy-container">
                <div class="controversy-section">
                    <h3 class="controversy-title most">üî• Most Controversial</h3>
                    <div id="mostControversialList" class="controversy-list">
                        <!-- Most controversial items -->
                    </div>
                </div>
                <div class="controversy-section">
                    <h3 class="controversy-title least">‚ùÑÔ∏è Least Controversial</h3>
                    <div id="leastControversialList" class="controversy-list">
                        <!-- Least controversial items -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Round Scoreboard -->
        <div id="roundScoreboard" class="hidden">
            <div class="phase-message">Round <span id="scoreboardRound">1</span> Results</div>
            <div class="scoreboard">
                <div id="scoreboardList">
                    <!-- Scores will be populated here -->
                </div>
            </div>
        </div>

    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io();
        let currentRoomCode = null;
        let playerCircles = [];

        // DOM elements
        const roomCodeDisplay = document.getElementById('roomCode');
        const waitingScreen = document.getElementById('waitingScreen');
        const categoryScreen = document.getElementById('categoryScreen');
        const votingScreen = document.getElementById('votingScreen');
        const resultsScreen = document.getElementById('resultsScreen');
        const controversySummary = document.getElementById('controversySummary');
        const roundScoreboard = document.getElementById('roundScoreboard');
        
        const categoryText = document.getElementById('categoryText');
        const phaseMessage = document.getElementById('phaseMessage');
        const submissionCounter = document.getElementById('submissionCounter');
        const voteCounter = document.getElementById('voteCounter');
        const currentExemplar = document.getElementById('currentExemplar');
        const votingArena = document.getElementById('votingArena');
        const splitDisplay = document.getElementById('splitDisplay');
        const scoreboardList = document.getElementById('scoreboardList');
        const waitingMessage = document.getElementById('waitingMessage');
        const playersWaiting = document.getElementById('playersWaiting');
        const playerBubbles = document.getElementById('playerBubbles');

        // Timer-related DOM elements
        const timerDisplay = document.getElementById('timerDisplay');
        const timerLabel = document.getElementById('timerLabel');
        const timerCountdown = document.getElementById('timerCountdown');
        const timerPhase = document.getElementById('timerPhase');
        const timerProgressBar = document.getElementById('timerProgressBar');


        // New enhanced results elements
        const resultProgress = document.getElementById('resultProgress');
        const yesCount = document.getElementById('yesCount');
        const noCount = document.getElementById('noCount');
        const mostControversialList = document.getElementById('mostControversialList');
        const leastControversialList = document.getElementById('leastControversialList');
        const scoreboardRound = document.getElementById('scoreboardRound');

        const votingCategoryDisplay = document.getElementById('votingCategoryDisplay');
        
        const lobbyScreen = document.getElementById('lobbyScreen');
        const lobbyMessage = document.getElementById('lobbyMessage');
        const lobbyPlayersWaiting = document.getElementById('lobbyPlayersWaiting');
        const lobbyPlayerBubbles = document.getElementById('lobbyPlayerBubbles');
        const categoryBubbles = document.getElementById('categoryBubbles');
        const hostCategoryInput = document.getElementById('hostCategoryInput');
        const addCategoryBtn = document.getElementById('addCategoryBtn');
        const startGameBtn = document.getElementById('startGameBtn');


        let currentTimer = {
            remaining: 0,
            total: 0,
            phase: '',
            isActive: false
        };

        // Host adds category
        addCategoryBtn.addEventListener('click', () => {
            const category = hostCategoryInput.value.trim();
            if (!category) {
                alert('Please enter a category');
                return;
            }
            
            socket.emit('host-add-category', { category });
        });

        // Start game from lobby
        startGameBtn.addEventListener('click', () => {
            if (confirm('Start the game? Players will begin submitting exemplars for the first category.')) {
                socket.emit('start-lobby-game');
            }
        });

        hostCategoryInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') addCategoryBtn.click();
        });

        // Connect to a room (URL parameter or prompt)
        window.addEventListener('load', () => {
            // Check if this is a host starting a new game vs joining existing display
            const urlParams = new URLSearchParams(window.location.search);
            const existingRoom = urlParams.get('room');
            
            if (!existingRoom) {
                // Host is starting new game - create room automatically
                socket.emit('create-room');
            } else {
                // Display joining existing room
                currentRoomCode = existingRoom.toUpperCase();
                roomCodeDisplay.textContent = currentRoomCode;
                socket.emit('join-display', { roomCode: currentRoomCode });
            }
        });

        // Handle category submissions update
        socket.on('categories-update', (data) => {
            updateCategoryBubbles(data.categorySubmissions);
        });

        socket.on('player-reconnected', (data) => {
            addPlayerBubble(data.nickname, false);
        });

        // Handle host category addition confirmation
        socket.on('category-added', (data) => {
            hostCategoryInput.value = '';
            // Could add a brief success indicator here
        });

        // Socket events
        socket.on('display-connected', (data) => {
            console.log('Display connected to room:', data.roomCode);
            showScreen('waiting');
        });

        socket.on('room-update', (data) => {
            console.log('Room update:', data);
            
            if (data.players) {
                populateInitialBubbles(data.players, lobbyPlayerBubbles);
                updateStartButtonState(data.playerCount, categoryBubbles.children.length);
            }
        });

        socket.on('display-update', (data) => {
            updateDisplay(data);
        });

        // Timer update handler
        socket.on('timer-update', (data) => {
            updateTimerDisplay(data.remaining, data.phase);
        });

        socket.on('player-joined', (data) => {
            addPlayerBubble(data.nickname, true);
        });

        socket.on('player-left', (data) => {
            removePlayerBubble(data.nickname);
        });

        socket.on('room-created', (data) => {
            currentRoomCode = data.roomCode;
            roomCodeDisplay.textContent = currentRoomCode;

            socket.emit('join-display', { roomCode: currentRoomCode });
            // Show lobby screen instead of waiting screen
            showScreen('lobby');
            
            console.log('Room created:', currentRoomCode);
        });

        socket.on('results-mode-start', (data) => {
            // Flip to the results interstitial so users see movement
            showScreen('results'); // your 'results' screen shows the waiting text
        });

        socket.on('show-exemplar-result', (data) => {
            console.log('show-exemplar-result received:', data.currentIndex + 1, '/', data.totalResults);
            showExemplarResultEnhanced(data);
        });


        socket.on('show-round-scoreboard', (data) => {
            console.log('Showing round scoreboard:', data);
            showRoundScoreboard(data);
        });


        socket.on('show-enhanced-summary', (data) => {
            console.log('Showing enhanced summary:', data);
            showEnhancedSummary(data);
        });


        // Function to update timer display
        function updateTimerDisplay(remaining, phase) {
            currentTimer.remaining = remaining;
            currentTimer.phase = phase;
            currentTimer.isActive = remaining > 0;
            
            if (!currentTimer.isActive) {
                timerDisplay.classList.add('hidden');
                return;
            }
            
            // Show timer
            timerDisplay.classList.remove('hidden');
            
            // Update countdown text
            const minutes = Math.floor(remaining / 60);
            const seconds = remaining % 60;
            timerCountdown.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            
            // Update phase label and text
            const phaseLabels = {
                'submission': 'Submit Exemplars',
                'voting': 'Vote on All',
                'results': 'Results'
            };
            
            timerLabel.textContent = phaseLabels[phase] || 'Time Remaining';
            timerPhase.textContent = getPhaseDescription(phase);
            
            // Update progress bar
            if (currentTimer.total === 0) {
                // First update for this phase - set total
                currentTimer.total = remaining;
            }
            
            const progress = ((currentTimer.total - remaining) / currentTimer.total) * 100;
            timerProgressBar.style.width = `${progress}%`;
            
            // Apply warning styles based on time remaining
            const percentRemaining = (remaining / currentTimer.total) * 100;
            
            // Remove existing warning classes
            timerCountdown.classList.remove('warning', 'critical');
            timerProgressBar.classList.remove('warning', 'critical');
            
            if (percentRemaining <= 10) {
                timerCountdown.classList.add('critical');
                timerProgressBar.classList.add('critical');
            } else if (percentRemaining <= 25) {
                timerCountdown.classList.add('warning');
                timerProgressBar.classList.add('warning');
            }
        }


        // Helper function for phase descriptions
        function getPhaseDescription(phase) {
            switch(phase) {
                case 'submission':
                    return 'Submit your exemplar';
                case 'voting':
                    return 'Vote yes/no on each';
                case 'results':
                    return 'Check results';
                default:
                    return 'Waiting...';
            }
        }

        function updateDisplay(data) {
            console.log('Display update received:', data);
            
            switch(data.gameState) {
                case 'lobby':
                    showScreen('lobby');
                    if (data.players) {
                        populateInitialBubbles(data.players, lobbyPlayerBubbles);
                        updateStartButtonState(data.players.length, data.categorySubmissions?.length || 0);
                    }
                    if (data.categorySubmissions) {
                        updateCategoryBubbles(data.categorySubmissions);
                    }
                    break;
                    
                case 'submitting':
                    showScreen('category');
                    categoryText.textContent = `"${data.currentCategory}"`;
                    phaseMessage.textContent = 'Players are submitting exemplars...';
                    updateSubmissionCounter(data.submittedCount || 0, data.totalPlayers);
                    break;
                    
                case 'voting':
                    showScreen('voting');
                    votingCategoryDisplay.textContent = `"${data.currentCategory}"`;
                    updateVoteCounter(data.votedCount || 0, data.totalPlayers);
                    break;
                    
                case 'results':
                    waitingMessage.textContent = 'Results are being displayed...';
                    break;
                    
                default:
                    showScreen('waiting');
                    waitingMessage.textContent = 'Waiting for game to start...';
                    if (data.players) {
                        populateInitialBubbles(data.players);
                    }
            }
        }

        function updateStartButtonState(playerCount, categoryCount) {
            const minPlayers = 2;
            const minCategories = 3;
            const totalCategories = categoryCount + 18; // You'll need to define PRESET_CATEGORIES
            
            if (playerCount >= minPlayers && totalCategories >= minCategories) {
                startGameBtn.disabled = false;
                startGameBtn.textContent = `Start Game (${playerCount} players, ${totalCategories} categories)`;
            } else {
                startGameBtn.disabled = true;
                let missing = [];
                if (playerCount < minPlayers) missing.push(`${minPlayers - playerCount} more players`);
                if (totalCategories < minCategories) missing.push(`${minCategories - totalCategories} more categories`);
                startGameBtn.textContent = `Need: ${missing.join(', ')}`;
            }
        }

        // Reset timer when phases change
        function resetTimer() {
            currentTimer = {
                remaining: 0,
                total: 0,
                phase: '',
                isActive: false
            };
            timerDisplay.classList.add('hidden');
        }

        // Display management functions
        function showScreen(screen) {
            [waitingScreen, categoryScreen, votingScreen, resultsScreen, 
            controversySummary, roundScoreboard, lobbyScreen].forEach(s => {
                s.classList.add('hidden');
            });

            switch(screen) {
                case 'lobby':
                    lobbyScreen.classList.remove('hidden');
                    lobbyMessage.textContent = 'Players are joining and submitting categories...';
                    break;
                    
                case 'waiting':
                    waitingScreen.classList.remove('hidden');
                    waitingMessage.textContent = 'Waiting for players to join...';
                    playersWaiting.style.display = 'block';
                    break;
                    
                case 'waiting-for-category':
                    categoryScreen.classList.remove('hidden');
                    categoryText.textContent = 'Need more categories!';
                    phaseMessage.textContent = 'Host can add categories using the controls below';
                    submissionCounter.style.display = 'none';
                    break;
                    
                case 'submitting':
                case 'category':
                    categoryScreen.classList.remove('hidden');
                    phaseMessage.textContent = 'Players are submitting exemplars...';
                    submissionCounter.style.display = 'block';
                    break;
                    
                case 'voting':
                    votingScreen.classList.remove('hidden');
                    break;
                    
                case 'results':
                    // Enhanced results mode - waiting for auto progression
                    waitingScreen.classList.remove('hidden');
                    waitingMessage.textContent = 'Preparing results...';
                    break;
                    
                case 'controversy':
                    controversySummary.classList.remove('hidden');
                    break;
                    
                case 'scoreboard':
                    roundScoreboard.classList.remove('hidden');
                    break;
                    
                default:
                    waitingScreen.classList.remove('hidden');
                    waitingMessage.textContent = 'Waiting for game to start...';
                    playersWaiting.style.display = 'block';
                    break;
            }
        }

        // Enhanced exemplar result display
        function showExemplarResultEnhanced(data) {
            // Don't call showScreen('results') - directly show the results screen
            [waitingScreen, categoryScreen, votingScreen, resultsScreen, controversySummary, roundScoreboard, lobbyScreen]
                .forEach(s => s && s.classList.add('hidden'));
            
            resultsScreen.classList.remove('hidden'); // Show the actual results screen
            
            // Update progress and exemplar text
            resultProgress.textContent = `Result ${data.currentIndex + 1} of ${data.totalResults}`;
            currentExemplar.textContent = `"${data.exemplar}"`;
            
            // Update vote counts
            yesCount.textContent = data.yesCount;
            noCount.textContent = data.noCount;
            
            // Update split display
            splitDisplay.textContent = `Split: ${data.yesCount} YES, ${data.noCount} NO (${data.points} points)`;
            
            // Create and animate player circles
            createAndAnimatePlayerCircles(data.votes);
        }

        // Helper function to update category bubbles
        function updateCategoryBubbles(categorySubmissions) {
            if (!categorySubmissions || categorySubmissions.length === 0) {
                categoryBubbles.innerHTML = '<div class="no-categories-message">No categories submitted yet...</div>';
                return;
            }

            // Remove "no categories" message if it exists
            const noCategoriesMsg = categoryBubbles.querySelector('.no-categories-message');
            if (noCategoriesMsg) {
                noCategoriesMsg.remove();
            }

            // Add new category bubbles
            categorySubmissions.forEach((submission, index) => {
                // Check if bubble already exists
                if (document.querySelector(`[data-category="${submission.category}"]`)) {
                    return;
                }

                const bubble = document.createElement('div');
                bubble.className = 'category-bubble new';
                bubble.textContent = `"${submission.category}" - ${submission.nickname}`;
                bubble.setAttribute('data-category', submission.category);
                
                categoryBubbles.appendChild(bubble);
                
                // Remove 'new' class after animation
                setTimeout(() => {
                    bubble.classList.remove('new');
                }, 500);
            });
        }

        // Helper function to populate player bubbles (reuse existing logic but allow different containers)
        function populateInitialBubbles(players, container = playerBubbles) {
            if (!players || players.length === 0) {
                container.innerHTML = '<div class="no-players-message">No players yet...</div>';
                return;
            }

            container.innerHTML = '';
            players.forEach((player, index) => {
                setTimeout(() => {
                    addPlayerBubble(player.nickname, false, container);
                }, index * 100);
            });
        }

        function createAndAnimatePlayerCircles(votes) {
            // Clear existing circles
            votingArena.querySelectorAll('.player-circle').forEach(circle => circle.remove());
            
            // Create circles starting in center
            const circles = votes.map((vote, index) => {
                const circle = document.createElement('div');
                circle.className = 'player-circle';
                circle.textContent = index + 1;
                
                // Start in center
                circle.style.left = '50%';
                circle.style.top = '50%';
                circle.style.transform = 'translate(-50%, -50%)';
                
                votingArena.appendChild(circle);
                return { element: circle, vote: vote.vote };
            });
            
            // Animate to sides after a brief delay
            setTimeout(() => {
                animateCirclesToSides(circles);
            }, 800);
        }

        function animateCirclesToSides(circles) {
            const arena = votingArena.getBoundingClientRect();
            const yesArea = votingArena.querySelector('.vote-side.yes').getBoundingClientRect();
            const noArea = votingArena.querySelector('.vote-side.no').getBoundingClientRect();
            
            const yesCircles = circles.filter(c => c.vote);
            const noCircles = circles.filter(c => !c.vote);
            
            // Animate YES circles
            yesCircles.forEach((circle, index) => {
                setTimeout(() => {
                    const cols = Math.ceil(Math.sqrt(yesCircles.length));
                    const row = Math.floor(index / cols);
                    const col = index % cols;
                    
                    const x = (col + 1) * (yesArea.width / (cols + 1));
                    const y = (row + 1) * (yesArea.height / (Math.ceil(yesCircles.length / cols) + 1));
                    
                    circle.element.classList.add('animating');
                    circle.element.style.left = x + 'px';
                    circle.element.style.top = y + 'px';
                    
                    // Remove animation class after completion
                    setTimeout(() => {
                        circle.element.classList.remove('animating');
                    }, 1200);
                }, index * 150);
            });
            
            // Animate NO circles
            noCircles.forEach((circle, index) => {
                setTimeout(() => {
                    const cols = Math.ceil(Math.sqrt(noCircles.length));
                    const row = Math.floor(index / cols);
                    const col = index % cols;
                    
                    const x = arena.width / 2 + (col + 1) * (noArea.width / (cols + 1));
                    const y = (row + 1) * (noArea.height / (Math.ceil(noCircles.length / cols) + 1));
                    
                    circle.element.classList.add('animating');
                    circle.element.style.left = x + 'px';
                    circle.element.style.top = y + 'px';
                    
                    // Remove animation class after completion
                    setTimeout(() => {
                        circle.element.classList.remove('animating');
                    }, 1200);
                }, index * 150);
            });
        }

        function showEnhancedSummary(data) {
            showScreen('controversy');
            
            // Update the title
            document.querySelector('#controversySummary .phase-message').textContent = data.title;
            
            if (data.showAll) {
                // Show all exemplars in a single column
                mostControversialList.innerHTML = '';
                
                // Update the section title
                document.querySelector('.controversy-title.most').textContent = 'üéØ All Exemplars';
                document.querySelector('.controversy-section').classList.add('full-width');
                
                // Hide the least controversial section
                document.querySelector('.controversy-section:last-child').style.display = 'none';
                
                // Populate all results
                mostControversialList.innerHTML = data.allResults.map((item, index) => `
                    <div class="controversy-item" style="animation-delay: ${index * 0.1}s">
                        <div class="controversy-rank">#${index + 1}</div>
                        <div class="controversy-exemplar">"${item.exemplar}"</div>
                        <div class="controversy-split">${item.yesCount} YES, ${item.noCount} NO</div>
                        <div class="controversy-points">${item.points} points</div>
                    </div>
                `).join('');
                
            } else {
                // Show top 3 and bottom 3
                document.querySelector('.controversy-title.most').textContent = 'üèÜ Top Scoring';
                document.querySelector('.controversy-title.least').textContent = 'üé≤ Lowest Scoring';
                document.querySelector('.controversy-section').classList.remove('full-width');
                document.querySelector('.controversy-section:last-child').style.display = 'block';
                
                // Populate top results
                mostControversialList.innerHTML = data.topResults.map((item, index) => `
                    <div class="controversy-item" style="animation-delay: ${index * 0.2}s">
                        <div class="controversy-rank">#${index + 1}</div>
                        <div class="controversy-exemplar">"${item.exemplar}"</div>
                        <div class="controversy-split">${item.yesCount} YES, ${item.noCount} NO</div>
                        <div class="controversy-points">${item.points} points</div>
                    </div>
                `).join('');
                
                // Populate bottom results (show their actual ranks)
                const totalResults = data.topResults.length + data.bottomResults.length + (data.bottomResults.length > 3 ? 0 : 0);
                leastControversialList.innerHTML = data.bottomResults.map((item, index) => {
                    const actualRank = totalResults - data.bottomResults.length + index + 1;
                    return `
                        <div class="controversy-item" style="animation-delay: ${index * 0.2}s">
                            <div class="controversy-rank">#${actualRank}</div>
                            <div class="controversy-exemplar">"${item.exemplar}"</div>
                            <div class="controversy-split">${item.yesCount} YES, ${item.noCount} NO</div>
                            <div class="controversy-points">${item.points} points</div>
                        </div>
                    `;
                }).join('');
            }
        }

       function showRoundScoreboard(data) {
            showScreen('scoreboard');
            
            // Update title based on whether this is final game results or round results
            let titleText;
            if (data.isFinal) {
                titleText = `üèÜ Final Game Results üèÜ`;
            } else if (data.isGameWide) {
                titleText = `Total Scores After Round ${data.round}`;
            } else {
                titleText = `Round ${data.round} Results`;
            }
            
            document.querySelector('#roundScoreboard .phase-message').innerHTML = titleText;
            
            const scoresHtml = data.players.map((player, index) => {
                // Add special styling for final game podium positions
                let rankEmoji = '';
                if (data.isFinal) {
                    if (index === 0) rankEmoji = 'ü•á ';
                    else if (index === 1) rankEmoji = 'ü•à ';
                    else if (index === 2) rankEmoji = 'ü•â ';
                }
                
                return `
                    <div class="score-item slide-in ${data.isFinal ? 'final-score' : ''}" style="animation-delay: ${index * 0.1}s">
                        <div>
                            <span class="score-rank">${rankEmoji}#${index + 1}</span>
                            ${player.nickname}
                        </div>
                        <div>${player.score} points</div>
                    </div>
                `;
            }).join('');
            
            scoreboardList.innerHTML = scoresHtml;
        }

        function addPlayerBubble(nickname, isNew = false, container = playerBubbles) {
            // Check if bubble already exists in this container
            if (container.querySelector(`[data-nickname="${nickname}"]`)) {
                return;
            }

            // Remove "no players" message if it exists
            const noPlayersMsg = container.querySelector('.no-players-message');
            if (noPlayersMsg) {
                noPlayersMsg.remove();
            }

            const bubble = document.createElement('div');
            bubble.className = `player-bubble ${isNew ? 'new' : 'existing'}`;
            bubble.textContent = nickname;
            bubble.setAttribute('data-nickname', nickname);
            
            const shimmer = document.createElement('div');
            shimmer.style.cssText = `
                position: absolute;
                top: 0;
                left: -100%;
                width: 100%;
                height: 100%;
                background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
                animation: shimmer 2s ease-in-out infinite;
                pointer-events: none;
            `;
            bubble.appendChild(shimmer);
            
            container.appendChild(bubble);
            
            if (isNew) {
                setTimeout(() => {
                    bubble.classList.remove('new');
                    bubble.classList.add('existing');
                }, 1000);
            }
        }

        function removePlayerBubble(nickname) {
            const bubble = document.querySelector(`[data-nickname="${nickname}"]`);
            if (bubble) {
                bubble.style.animation = 'bubblePop 0.3s reverse';
                setTimeout(() => {
                    bubble.remove();
                    
                    // Check if no players left, show message
                    const remainingPlayers = playerBubbles.querySelectorAll('.player-bubble').length;
                    if (remainingPlayers === 0) {
                        playerBubbles.innerHTML = '<div class="no-players-message">No players yet...</div>';
                    }
                }, 300);
            }
        }

        function updateSubmissionCounter(submitted, total) {
            submissionCounter.textContent = `${submitted} / ${total} players have submitted`;
        }

        function updateVoteCounter(voted, total) {
            voteCounter.textContent = `${voted} / ${total} players have voted`;
        }

        // Handle connection errors
        socket.on('connect_error', () => {
            alert('Connection error. Please refresh the page.');
        });

        socket.on('error', (data) => {
            alert('Error: ' + data.message);
        });
    </script>
</body>
</html>